from sklearn.metrics import roc_curve, auc
import matplotlib.pyplot as plt

from Data import Dataset
from Methods import FeatureDescriptorMatching, MinutiaeMatching, PretrainedCNNModel


class Evaluation:
    """Main class for fingerprint authentication and identification."""

    def __init__(self, matcher, database):
        """Initialize with a matcher and a database of stored fingerprint templates."""
        self.matcher = matcher
        self.database = database

    def authenticate(self, claimed_id, probe_fingerprint):
        """
        Authenticate the claimed ID using the given fingerprint.

        Args:
            claimed_id (str): The ID being claimed by the user.
            probe_fingerprint (array-like): The fingerprint provided by the user for authentication.

        Returns:
            bool: True if authenticated, False otherwise.
        """
        template = self.database[claimed_id]
        score = self.matcher.match(template, probe_fingerprint)
        threshold = 0.8
        return score > threshold

    def identify(self, probe_fingerprint):
        """
        Identify the user based on the given fingerprint.

        Args:
            probe_fingerprint (array-like): The fingerprint provided by the user for identification.

        Returns:
            str: The identified user's ID or "Unknown" if no match is found.
        """
        scores = {id: self.matcher.match(template, probe_fingerprint) for id, template in self.database.items()}
        best_match_id = max(scores, key=scores.get)
        threshold = 0.8
        return best_match_id if scores[best_match_id] > threshold else "Unknown"
    
    def calculate_tar(true_positives, false_negatives):
        """
        Calculate the True Acceptance Rate (TAR).

        Parameters:
            true_positives (float): Number of true positive instances.
            false_negatives (float): Number of false negative instances.

        Returns:
            float: The True Acceptance Rate (TAR) in percentage.

        (ChatGPT: This function is generated by ChatGPT.)
        """

        tar = (true_positives / (true_positives + false_negatives)) * 100
        return tar


    def calculate_far(false_positives, true_negatives):
        """
        Calculate the False Acceptance Rate (FAR).

        Parameters:
            false_positives (float): Number of false positive instances.
            true_negatives (float): Number of true negative instances.

        Returns:
            float: The False Acceptance Rate (FAR) in percentage.

        (ChatGPT: This function is generated by ChatGPT.)
        """

        far = (false_positives / (false_positives + true_negatives)) * 100
        return far


    def calculate_trr(true_negatives, false_positives):
        """
        Calculate the True Rejection Rate (TRR).

        Parameters:
            true_negatives (float): Number of true negative instances.
            false_positives (float): Number of false positive instances.

        Returns:
            float: The True Rejection Rate (TRR) in percentage.

        (ChatGPT: This function is generated by ChatGPT.)
        """

        trr = (true_negatives / (true_negatives + false_positives)) * 100
        return trr


    def calculate_frr(false_negatives, true_positives):
        """
        Calculate the False Rejection Rate (FRR).

        Parameters:
            false_negatives (float): Number of false negative instances.
            true_positives (float): Number of true positive instances.

        Returns:
            float: The False Rejection Rate (FRR) in percentage.

        (ChatGPT: This function is generated by ChatGPT.)
        """

        frr = (false_negatives / (false_negatives + true_positives)) * 100
        return frr


    def plot_roc_curve(y_test, y_prob):
        """
        Plot the Receiver Operating Characteristic (ROC) curve.

        Parameters:
            y_test (array-like): True labels of the test set.
            y_prob (array-like): Predicted probabilities of the positive class.

        Returns:
            None

        (ChatGPT: This function is adapted from sklearn.metrics.roc_curve.)
        """

        fpr, tpr, _ = roc_curve(y_test, y_prob)
        roc_auc = auc(fpr, tpr)

        # Plot ROC curve
        plt.figure()
        plt.plot(fpr, tpr, color='darkorange', lw=2, label=f'ROC curve (area = {roc_auc:.2f})')
        plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
        plt.xlabel('False Positive Rate')
        plt.ylabel('True Positive Rate')
        plt.title('Receiver Operating Characteristic (ROC) Curve')
        plt.legend(loc='lower right')
        plt.show()


    def plot_det_curve(fpr, fnr, label='DET Curve'):
        """
        Plot the Detection Error Tradeoff (DET) curve.

        Parameters:
            fpr (array-like): False Positive Rate values.
            fnr (array-like): False Negative Rate values.
            label (str): Label for the DET Curve.

        Returns:
            None

        (ChatGPT: This function is adapted from DETCurve.)
        """

        plt.figure()
        plt.plot(fpr, fnr, color='darkorange', lw=2, label=label)
        plt.xscale('log')
        plt.yscale('log')
        plt.xlabel('False Positive Rate (FPR)')
        plt.ylabel('False Negative Rate (FNR)')
        plt.title('Detection Error Tradeoff (DET) Curve')
        plt.legend(loc='upper right')
        plt.show()

    def compute_rank_k_recognition_rate(self, identification_results, k_values):
        """
        Compute rank-k recognition rates.

        Args:
            identification_results (list): List of identified users for each probe.
            k_values (list): List of rank values to compute recognition rates.

        Returns:
            dict: A dictionary containing rank-k recognition rates.
        CODE PROVIDED BY CHATGPT
        """
        rank_k_recognition_rates = {}

        for k in k_values:
            # Keep only the top-k identified users for each probe
            top_k_identifications = [ident[:k] for ident in identification_results]

            # Compute the recognition rate at rank-k
            true_positives = 0
            total_probes = len(top_k_identifications)

            for ident_list in top_k_identifications:
                if "true_user" in ident_list:  # Modify based on your actual true user identification
                    true_positives += 1

            recognition_rate = true_positives / total_probes
            rank_k_recognition_rates[f'Rank-{k}'] = recognition_rate

    

if __name__ == "__main__":
    dataset_path = r"C:/Users/CharB/OneDrive/Desktop/HW3_Dataset"
    dataset = Dataset(dataset_path)

      # Load template and probe fingerprints
    template_images = dataset.load_images('Template')
    probe_easy_images = dataset.load_images('TestEasy')
    probe_medium_images = dataset.load_images('TestMedium')
    probe_hard_images = dataset.load_images('TestHard')
    print("Datasets loaded")
    
    # Create MinutiaeMatching instance
    minutiae_matcher = MinutiaeMatching()

    # Create Evaluation instance
    evaluation = Evaluation(minutiae_matcher, template_images)

    # Gather identification results for MinutiaeMatching
    identification_results = []
    
    for template_attributes, template_image in template_images.items():
        for probe_attributes, probe_image in probe_easy_images.items():
            # Call the identify function
            identified_user = evaluation.identify(probe_image)
            identification_results.append(identified_user)

    # Specify the rank values to compute recognition rates (e.g., 1 to 5)
    k_values = [1, 2, 3, 4, 5]

    # Compute and print rank-k recognition rates
    rank_k_recognition_rates = evaluation.compute_rank_k_recognition_rate(identification_results, k_values)
    for k, recognition_rate in rank_k_recognition_rates.items():
        print(f'{k} Recognition Rate: {recognition_rate * 100:.2f}%')
    
    # Create FeatureDescriptorMatching instance with SIFT
    sift_feature_matcher = FeatureDescriptorMatching(method="SIFT")
    
    # Create PretrainedCNNModel instance (provide the actual model name)
    cnn_feature_matcher = PretrainedCNNModel(model_name="VGG16")

    # Gather identification results for MinutiaeMatching
    identification_results_minutiae = []
    for template_attributes, template_image in template_images.items():
        for probe_attributes, probe_image in probe_easy_images.items():
            # Call the identify function
            identified_user = minutiae_matcher.identify(probe_image)
            identification_results_minutiae.append(identified_user)

    # Gather identification results for FeatureDescriptorMatching (SIFT)
    identification_results_sift = []
    for template_attributes, template_image in template_images.items():
        for probe_attributes, probe_image in probe_medium_images.items():
            # Call the identify function
            identified_user = sift_feature_matcher.identify(probe_image)
            identification_results_sift.append(identified_user)

    # Gather identification results for PretrainedCNNModel
    identification_results_cnn = []
    for template_attributes, template_image in template_images.items():
        for probe_attributes, probe_image in probe_hard_images.items():
            # Call the identify function
            identified_user = cnn_feature_matcher.identify(probe_image)
            identification_results_cnn.append(identified_user)
        
    # Perform authentication for different methods and compare performance
    methods = ['MinutiaeMatching', 'SIFT FeatureDescriptorMatching', 'PretrainedCNNModel']

    for method, identification_results in zip(methods, [identification_results_minutiae, identification_results_sift, identification_results_cnn]):
        true_positives = 0
        false_negatives = 0

        for claimed_id, template_image in template_images.items():
            for probe_attributes, probe_image in probe_easy_images.items():
                # Call the authenticate function for the current method
                authenticated = (claimed_id in identification_results)  # Assuming the identified_user is the claimed_id
                # Update true positives and false negatives
                if claimed_id == "true_user" and authenticated:
                    true_positives += 1
                elif claimed_id != "true_user" and not authenticated:
                    false_negatives += 1

        # Calculate and print True Acceptance Rate (TAR)
        tar = Evaluation.calculate_tar(true_positives, false_negatives)
        print(f'{method} TAR: {tar:.2f}%')
        
        #These tests were derived from ChatGPT